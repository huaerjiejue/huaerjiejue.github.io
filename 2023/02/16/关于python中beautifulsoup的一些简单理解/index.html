<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>  · 小阔的bug日常</title><meta name="description" content=" - 小阔"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://huaerjiejue.github.io/atom.xml" title="小阔的bug日常"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="小阔的bug日常" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title"></h1><div class="post-info">2023年2月16日</div><div class="post-content"><h1 id="关于python中beautifulsoup的一些简单理解"><a href="#关于python中beautifulsoup的一些简单理解" class="headerlink" title="关于python中beautifulsoup的一些简单理解"></a>关于python中beautifulsoup的一些简单理解</h1><p>[TOC]</p>
<p>  首先介绍下何为beautifulsoup，下面是官方的一种解释：</p>
<p>  [Beautiful Soup](<a target="_blank" rel="noopener" href="https://beautifulsoup.cn/">Beautiful Soup 中文文档</a>) 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.</p>
<p>  前面的一些准备工作就不介绍了，就是简单包的安装与引用，这篇bolg主要介绍一下相应的用法：</p>
<p>  首先就是开始，要把html文件喂给beautifulsoup，常见有三种格式，一种是html&#x3D;’’’  ‘’’，在内容较小的情况下直接放上去就好，另外一种是通过文件引用，把网站的html放到一个文件中，通过<code>soup1 = BeautifulSoup(open(&#39;index.html&#39;))  </code>来引用，还有一种是结合requests进行引用，具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">url = <span class="string">&#x27;https://www.example.com&#x27;</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line">html = response.text</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">&#x27;html.parser&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>  下面我们可以打印soup对象的内容<code>print(soup.prettify())</code>即可</p>
<h2 id="接下来来说一下beautifulsoup中的4中对象"><a href="#接下来来说一下beautifulsoup中的4中对象" class="headerlink" title="接下来来说一下beautifulsoup中的4中对象"></a>接下来来说一下beautifulsoup中的4中对象</h2><ul>
<li>Tag</li>
<li>NavigableString</li>
<li>BeautifulSoup </li>
<li>Comment</li>
</ul>
<h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><title>The Dormouse's story</title>

<p>  上面是一个正常的html代码，其中title就是标签，也就是tag，后面跟着的东西就叫做属性，要获取它很容易，soup后面直接点出来就好了，比如要获得上面的tag，输入soup.title即可。这个tag中可以获得两个东西，分别是name和attrs，是它的名字和属性，名字好说，就是这个tag叫什么，attrs的话可以简单通过一个例子来看，这样最直观，我们看下面的例子<b class="boldest">，这是一段html代码，其中b就是tag，当然这个tag的名字就是b，它的attrs呢，就是class&#x3D;”boldest”这个东西，我们对tag属性的操作就把它当作字典看待就好，直接输入soup.b[class]就会显现这个soup中b这个tag的class这个属性所对应的内容，当然也可以直接用soup.b.attrs可以全部显示出来。我们还可以对这些属性进行操作，就按照正常的字典对待就好。</p>
<p>  顺表说一下，tag也是直接可以改动的，但是上面直接点出来tag的方式只是返回所给内容中第一个符合标准的tag，要获得所有的或者有一些限制的后面会写到。</p>
<h4 id="Tag的多值属性"><a href="#Tag的多值属性" class="headerlink" title="Tag的多值属性"></a>Tag的多值属性</h4><p>  对于一些个别属性，HTML4定义了一些可以包含多个值的属性，包括但不限于class,rel,rev,accept-charset,headers,accesskey等，如果这些属性有多个值，在BeautifulSoup中返回一个list，举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">css_soup = BeautifulSoup(<span class="string">&#x27;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">css_soup.p[<span class="string">&#x27;class&#x27;</span>]</span><br><span class="line"><span class="comment"># [&quot;body&quot;, &quot;strikeout&quot;]</span></span><br><span class="line"></span><br><span class="line">css_soup = BeautifulSoup(<span class="string">&#x27;&lt;p class=&quot;body&quot;&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">css_soup.p[<span class="string">&#x27;class&#x27;</span>]</span><br><span class="line"><span class="comment"># [&quot;body&quot;]</span></span><br></pre></td></tr></table></figure>

<p>  但是对于其他属性，HTML则内有规定，如果这些属性有多个值的话，则会以字符串格式返回，同样，举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">id_soup = BeautifulSoup(<span class="string">&#x27;&lt;p id=&quot;my id&quot;&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">id_soup.p[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line"><span class="comment"># &#x27;my id&#x27;</span></span><br></pre></td></tr></table></figure>

<p>  如果我们通过tag将属性的单个值改为多个值的时候，多值属性就会何为一个值，例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rel_soup = BeautifulSoup(<span class="string">&#x27;&lt;p&gt;Back to the &lt;a rel=&quot;index&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">rel_soup.a[<span class="string">&#x27;rel&#x27;</span>]</span><br><span class="line"><span class="comment"># [&#x27;index&#x27;]</span></span><br><span class="line">rel_soup.a[<span class="string">&#x27;rel&#x27;</span>] = [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;contents&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(rel_soup.p)</span><br><span class="line"><span class="comment"># &lt;p&gt;Back to the &lt;a rel=&quot;index contents&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="NavigableString"><a href="#NavigableString" class="headerlink" title="NavigableString"></a>NavigableString</h3><p>  NavigableString叫做可以遍历的字符串，字符串通常在tag内，tag内这些字符串对于BeautifulSoup来说就是可以遍历的字符串，是在tag中，但是不是属性的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tag.string</span><br><span class="line"><span class="comment"># u&#x27;Extremely bold&#x27;</span></span><br><span class="line"><span class="built_in">type</span>(tag.string)</span><br><span class="line"><span class="comment"># &lt;class &#x27;bs4.element.NavigableString&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>  我们可以对NavigableString进行格式转换和转换，注意，不可以编辑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unicode_string = unicode(tag.string)</span><br><span class="line">unicode_string</span><br><span class="line"><span class="comment"># u&#x27;Extremely bold&#x27;</span></span><br><span class="line"><span class="built_in">type</span>(unicode_string)</span><br><span class="line"><span class="comment"># &lt;type &#x27;unicode&#x27;&gt;</span></span><br><span class="line">tag.string.replace_with(<span class="string">&quot;No longer bold&quot;</span>)</span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;blockquote&gt;No longer bold&lt;/blockquote&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><p>  BeautifulSoup对象表示一个文档的全部内容，大部分时候可以把他当作Tag对象</p>
<h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>  文档注释，仅此而已，comment是特殊的NavigableString对象，所以他也可以用.string引用，但是当他出现在HTML文档中，他会以特殊形式输出</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>  何为节点，节点（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=node&spm=1001.2101.3001.7020">node</a>）是构成我们网页的最基本的组成部分，网页中的每一个部分都可以称为是一个节点。例如： html 元素、属性、文本、注释、整个文档等都是一个节点。因为HTML上面有很多内容，每个小块打开有有很多的小块，所谓子节点，就是目前打开节点下面的小节点，同理，父节点和兄弟节点也就比较好理解了，父节点就是该节点上面的节点，兄弟节点即使与该节点同级的节点，在下面就不一一论述了。</p>
<h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><h4 id="tag的名字"><a href="#tag的名字" class="headerlink" title="tag的名字"></a>tag的名字</h4><p>如果想要获取有tag，直接通过点的方式就好看，比如想要获取当前下<b>的tag，直接tag.b即可，想要获取更深一层的tag，再点一层就好了。但是这有一个问题，就是只可以得到第一个符合此描述的方法，要获得所有的，可以使用find_all()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure>

<p>当然我们可以通过<code>.contents</code>将tag的子节点以列表形式输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head_tag = soup.head</span><br><span class="line">head_tag</span><br><span class="line"><span class="comment"># &lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"></span><br><span class="line">head_tag.contents</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]</span></span><br><span class="line"></span><br><span class="line">title_tag = head_tag.contents[<span class="number">0</span>]</span><br><span class="line">title_tag</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;</span></span><br><span class="line">title_tag.contents</span><br><span class="line"><span class="comment"># [u&#x27;The Dormouse&#x27;s story&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>同样，我们也可以通过哦.children进行遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> title_tag.children:</span><br><span class="line">    <span class="built_in">print</span>(child)</span><br><span class="line">    <span class="comment"># The Dormouse&#x27;s story</span></span><br></pre></td></tr></table></figure>

<p>不同的是，contents以列表形式返回，children以迭代器形式返回</p>
<h4 id="descendants"><a href="#descendants" class="headerlink" title=".descendants"></a>.descendants</h4><p>通过.contents和.children我们可以获得当前节点下一层的节点，但是如果下一层节点还有一层节点呢，这是我们就要使用.descendants对所有tag的子孙节点就行递归循环了，相当于更进一层的.children，举例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head_tag.contents</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> head_tag.descendants:</span><br><span class="line">    <span class="built_in">print</span>(child)</span><br><span class="line">    <span class="comment"># &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;</span></span><br><span class="line">    <span class="comment"># The Dormouse&#x27;s story</span></span><br></pre></td></tr></table></figure>

<h4 id="string"><a href="#string" class="headerlink" title=".string"></a>.string</h4><p>上面讲的都是与tag类型相关的操作，这个是与NavigableString类型相关，通过.string我们可以得到相应tag下面的子节点，类型是可遍历字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title_tag.string</span><br><span class="line"><span class="comment"># u&#x27;The Dormouse&#x27;s story&#x27;</span></span><br><span class="line">head_tag.contents</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]</span></span><br><span class="line"></span><br><span class="line">head_tag.string</span><br><span class="line"><span class="comment"># u&#x27;The Dormouse&#x27;s story&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当但，如果tag仅有一个子节点，我们可以通过.string，但是如果如果有很多的话.string的输出结果就是NONE了，这时我们就可以通过.strings就行循环获取，注意这个是有s的呦</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> soup.strings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(string))</span><br><span class="line">    <span class="comment"># u&quot;The Dormouse&#x27;s story&quot;</span></span><br><span class="line">    <span class="comment"># u&#x27;\n\n&#x27;</span></span><br><span class="line">    <span class="comment"># u&quot;The Dormouse&#x27;s story&quot;</span></span><br><span class="line">    <span class="comment"># u&#x27;\n\n&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;Once upon a time there were three little sisters; and their names were\n&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;Elsie&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;,\n&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;Lacie&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27; and\n&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;Tillie&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;;\nand they lived at the bottom of a well.&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;\n\n&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;...&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure>

<p>关于上面的repr（），函数的作用是将每个字符串对象的“官方”字符串表示打印出来，以便我们查看其中是否包含特殊字符和空格等问题。上面的\n就是他的杰作</p>
<p>当然，大部分情况下，我们不喜欢那些空行和空格，我们可以使用.stripped_strings进行去除多余的空白内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> soup.stripped_strings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(string))</span><br><span class="line">    <span class="comment"># u&quot;The Dormouse&#x27;s story&quot;</span></span><br><span class="line">    <span class="comment"># u&quot;The Dormouse&#x27;s story&quot;</span></span><br><span class="line">    <span class="comment"># u&#x27;Once upon a time there were three little sisters; and their names were&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;Elsie&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;,&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;Lacie&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;and&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;Tillie&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;;\nand they lived at the bottom of a well.&#x27;</span></span><br><span class="line">    <span class="comment"># u&#x27;...&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><h4 id="parent"><a href="#parent" class="headerlink" title=".parent"></a>.parent</h4><p>获取当前节点的上一层节点，举个例子最明白不过了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title_tag = soup.title</span><br><span class="line">title_tag</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;</span></span><br><span class="line">title_tag.parent</span><br><span class="line"><span class="comment"># &lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br></pre></td></tr></table></figure>

<p>文档顶层节点如<html>的父节点是BeautifulSoup对象，再网上一层的parent就是none了</p>
<h4 id="parents"><a href="#parents" class="headerlink" title=".parents"></a>.parents</h4><p>递归用法</p>
<h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><h4 id="next-sibling-和-previous-sibling"><a href="#next-sibling-和-previous-sibling" class="headerlink" title=".next_sibling 和 .previous_sibling"></a>.next_sibling 和 .previous_sibling</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sibling_soup = BeautifulSoup(<span class="string">&quot;&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(sibling_soup.prettify())</span><br><span class="line"><span class="comment"># &lt;html&gt;</span></span><br><span class="line"><span class="comment">#  &lt;body&gt;</span></span><br><span class="line"><span class="comment">#   &lt;a&gt;</span></span><br><span class="line"><span class="comment">#    &lt;b&gt;</span></span><br><span class="line"><span class="comment">#     text1</span></span><br><span class="line"><span class="comment">#    &lt;/b&gt;</span></span><br><span class="line"><span class="comment">#    &lt;c&gt;</span></span><br><span class="line"><span class="comment">#     text2</span></span><br><span class="line"><span class="comment">#    &lt;/c&gt;</span></span><br><span class="line"><span class="comment">#   &lt;/a&gt;</span></span><br><span class="line"><span class="comment">#  &lt;/body&gt;</span></span><br><span class="line"><span class="comment"># &lt;/html&gt;</span></span><br><span class="line">sibling_soup.b.next_sibling</span><br><span class="line"><span class="comment"># &lt;c&gt;text2&lt;/c&gt;</span></span><br><span class="line"></span><br><span class="line">sibling_soup.c.previous_sibling</span><br><span class="line"><span class="comment"># &lt;b&gt;text1&lt;/b&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里我们要注意了，通常你以为的不是你以为的，比如下面的例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/elsie&quot;</span> <span class="attr">class</span>=<span class="string">&quot;sister&quot;</span> <span class="attr">id</span>=<span class="string">&quot;link1&quot;</span>&gt;</span>Elsie<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/lacie&quot;</span> <span class="attr">class</span>=<span class="string">&quot;sister&quot;</span> <span class="attr">id</span>=<span class="string">&quot;link2&quot;</span>&gt;</span>Lacie<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/tillie&quot;</span> <span class="attr">class</span>=<span class="string">&quot;sister&quot;</span> <span class="attr">id</span>=<span class="string">&quot;link3&quot;</span>&gt;</span>Tillie<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果以为第一个<a>标签的 <code>.next_sibling</code> 结果是第二个<a>标签,那就错了,真实结果是第一个<a>标签和第二个<a>标签之间的顿号和换行符:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">link = soup.a</span><br><span class="line">link</span><br><span class="line"><span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line">link.next_sibling</span><br><span class="line"><span class="comment"># u&#x27;,\n&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="next-siblings-和-previous-siblings"><a href="#next-siblings-和-previous-siblings" class="headerlink" title=".next_siblings 和 .previous_siblings"></a>.next_siblings 和 .previous_siblings</h4><p>用于遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> soup.a.next_siblings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(sibling))</span><br><span class="line">    <span class="comment"># u&#x27;,\n&#x27;</span></span><br><span class="line">    <span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span></span><br><span class="line">    <span class="comment"># u&#x27; and\n&#x27;</span></span><br><span class="line">    <span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span></span><br><span class="line">    <span class="comment"># u&#x27;; and they lived at the bottom of a well.&#x27;</span></span><br><span class="line">    <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> soup.find(<span class="built_in">id</span>=<span class="string">&quot;link3&quot;</span>).previous_siblings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(sibling))</span><br><span class="line">    <span class="comment"># &#x27; and\n&#x27;</span></span><br><span class="line">    <span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span></span><br><span class="line">    <span class="comment"># u&#x27;,\n&#x27;</span></span><br><span class="line">    <span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span></span><br><span class="line">    <span class="comment"># u&#x27;Once upon a time there were three little sisters; and their names were\n&#x27;</span></span><br><span class="line">    <span class="comment"># None</span></span><br></pre></td></tr></table></figure>

<h4 id="next-element-和-previous-element"><a href="#next-element-和-previous-element" class="headerlink" title=".next_element 和 .previous_element"></a>.next_element 和 .previous_element</h4><p>指向下一个或上一个被解析的对象</p>
<h4 id="next-elements-和-previous-elements"><a href="#next-elements-和-previous-elements" class="headerlink" title=".next_elements 和 .previous_elements"></a>.next_elements 和 .previous_elements</h4><p>迭代</p>
<p>大部分情况下，sibling和element没有太大的区别，随便用就好。</p>
<h2 id="搜索文档数"><a href="#搜索文档数" class="headerlink" title="搜索文档数"></a>搜索文档数</h2><p>  BeautifulSoup中定义了很多搜索方法，我们主要了解两个find() and find_all()</p>
<p>在BeautifulSoup中，<code>find()</code>和<code>find_all()</code>方法都用于在文档树中查找元素。主要区别在于<code>find()</code>方法只返回第一个匹配的元素，而<code>find_all()</code>方法返回所有匹配的元素列表。</p>
<p>  find_all()有很多查询方法：</p>
<h3 id="字符串查询"><a href="#字符串查询" class="headerlink" title="字符串查询"></a>字符串查询</h3><p>  这个很简单，就是通过输入名称查询</p>
<p>1.通过tag查询，直接输入就好，返回tag为b的html文档</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># [&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;]</span></span><br></pre></td></tr></table></figure>

<p>2.通过keyword进行查询，返回属性中有id并且id为link2的html文档</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="built_in">id</span>=<span class="string">&#x27;link2&#x27;</span>)</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure>

<h3 id="正则表达式查询"><a href="#正则表达式查询" class="headerlink" title="正则表达式查询"></a>正则表达式查询</h3><p>通过正则表达式查询，记得引用re库，下面例子就是查找所有tag中以b开头的html文档</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(re.<span class="built_in">compile</span>(<span class="string">&quot;^b&quot;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(tag.name)</span><br><span class="line"><span class="comment"># body</span></span><br><span class="line"><span class="comment"># b</span></span><br></pre></td></tr></table></figure>

<p>但是通过这我们只能以tag进行查找，通过属性进行查询呢？我们可以这样写，查找tag为div中class为example的html文档</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment"># 使用正则表达式查找class属性为&quot;example&quot;的&lt;div&gt;元素</span></span><br><span class="line"></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\bexample\b&#x27;</span>)</span><br><span class="line">divs = soup.find_all(<span class="string">&#x27;div&#x27;</span>, class_=pattern)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">    <span class="built_in">print</span>(div)</span><br></pre></td></tr></table></figure>



<h3 id="列表查询"><a href="#列表查询" class="headerlink" title="列表查询"></a>列表查询</h3><p>列表查询就是对于列表中全部进行查询</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>])</span><br><span class="line"><span class="comment"># [&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure>

<h3 id="True查询"><a href="#True查询" class="headerlink" title="True查询"></a>True查询</h3><p>True可以匹配任意值，通过下面的代码可以查找到所有tag，但是不会返回字符串节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span>(tag.name)</span><br></pre></td></tr></table></figure>

<p>下面是通过属性和True进行查询</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用id=True参数查找所有具有id属性的元素 </span></span><br><span class="line">ids = soup.find_all(<span class="built_in">id</span>=<span class="literal">True</span>) </span><br></pre></td></tr></table></figure>

<h3 id="方法查询"><a href="#方法查询" class="headerlink" title="方法查询"></a>方法查询</h3><p>  有些情况下，我们查询要有很多的条件，比如要找到一个节点，包括class属性，但是不包含id属性，我们这时就可以通过方法进行查询</p>
<p>  首先，我们定义一个函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">has_class_but_no_id</span>(<span class="params">tag</span>):</span><br><span class="line">    <span class="keyword">return</span> tag.has_attr(<span class="string">&#x27;class&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> tag.has_attr(<span class="string">&#x27;id&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>  然后，我们将这个方法插入<code>find_all()</code>方法进行查询就可以了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(has_class_but_no_id)</span><br><span class="line"><span class="comment"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;p class=&quot;story&quot;&gt;Once upon a time there were...&lt;/p&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>  Beautiful Soup支持大部分的CSS选择器 <a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/selector.html">http://www.w3.org/TR/CSS2/selector.html</a> [<a target="_blank" rel="noopener" href="https://beautifulsoup.cn/#id94">6]</a> , 在 <code>Tag</code> 或 <code>BeautifulSoup</code> 对象的 <code>.select()</code> 方法中传入字符串参数, 即可使用CSS选择器的语法找到tag</p>
<h3 id="limit参数"><a href="#limit参数" class="headerlink" title="limit参数"></a>limit参数</h3><p>  通过limit限制返回结果的数量，加入有3个符合条件，输入limit&#x3D;1就会只返回两个符合条件的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">&quot;a&quot;</span>, limit=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure>

<h3 id="recursive参数"><a href="#recursive参数" class="headerlink" title="recursive参数"></a>recursive参数</h3><p>  调用tag的 <code>find_all()</code> 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 <code>recursive=False</code> </p>
<p>下面是一段简单的文档</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">   The Dormouse&#x27;s story</span><br><span class="line">  <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>是否使用该参数进行搜索</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.html.find_all(<span class="string">&quot;title&quot;</span>)</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.html.find_all(<span class="string">&quot;title&quot;</span>, recursive=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure>

<h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><ul>
<li>find_parents() 和 find_parent()，<code>find_parents()</code> 和 <code>find_parent()</code> 用来搜索当前节点的父辈节点</li>
<li>find_next_siblings() 和 find_next_sibling()，<code>find_next_siblings()</code> 方法返回所有符合条件的后面的兄弟节点, <code>find_next_sibling()</code> 只返回符合条件的后面的第一个tag节点.</li>
<li>find_previous_siblings() 和 find_previous_sibling()<code>find_previous_siblings()</code> 方法返回所有符合条件的前面的兄弟节点, <code>find_previous_sibling()</code> 方法返回第一个符合条件的前面的兄弟节点</li>
<li>find_all_next() 和 find_next()，<code>find_all_next()</code> 方法返回所有符合条件的节点, <code>find_next()</code> 方法返回第一个符合条件的节点</li>
<li>find_all_previous() 和 find_previous()<code>find_all_previous()</code> 方法返回所有符合条件的节点, <code>find_previous()</code> 方法返回第一个符合条件的节点.</li>
</ul>
<p>下面就是一些简单的修改包装，这里就不一一记述了，这篇文章的目的主要是为了自己的巩固和学习，加油，奥里给。具体可以参考<a target="_blank" rel="noopener" href="https://beautifulsoup.readthedocs.io/zh_CN/latest/">官方文章</a>，贼详细。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2023/03/02/%E5%B0%8F%E5%B0%8F%E6%80%9D%E8%80%83/" class="prev">PREV</a><a href="/2023/02/13/sqli-46/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2023 <a href="https://huaerjiejue.github.io">小阔</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>