<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小阔的bug日常</title>
  
  <subtitle>bug改不完了</subtitle>
  <link href="https://huaerjiejue.github.io/atom.xml" rel="self"/>
  
  <link href="https://huaerjiejue.github.io/"/>
  <updated>2023-02-01T14:30:08.620Z</updated>
  <id>https://huaerjiejue.github.io/</id>
  
  <author>
    <name>小阔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CPU的一点拆分理解</title>
    <link href="https://huaerjiejue.github.io/2023/02/01/CPU%E7%9A%84%E4%B8%80%E7%82%B9%E6%8B%86%E5%88%86%E7%90%86%E8%A7%A3/"/>
    <id>https://huaerjiejue.github.io/2023/02/01/CPU%E7%9A%84%E4%B8%80%E7%82%B9%E6%8B%86%E5%88%86%E7%90%86%E8%A7%A3/</id>
    <published>2023-02-01T11:58:38.000Z</published>
    <updated>2023-02-01T14:30:08.620Z</updated>
    
    <content type="html"><![CDATA[<p>  关于CPU，以前总是感觉很奇妙，最近观看关于计算机比较底层的视频，有了一点理解。</p><p>说实话，对于CPU，我以前简单的认为它是算术逻辑单元（ALU），其实这是错误的，关于讲解CPU之前，我们要先了解两个东东：ALU和内存</p><h2 id="ALU："><a href="#ALU：" class="headerlink" title="ALU："></a>ALU：</h2><p>什么是alu，它的全称叫做运算逻辑基本单元，根据名字我们就可以大概知道它是用于运算的，我们通过晶体管（可以用来表示0和1两种状态的东西）以不同的逻辑连接（与，或，非，异或）就可以进行不同的算术逻辑运算了。其实我一开始是迷茫的，你他妈怎么运算啊，总不能里面有个人脑，但是看视频的时候，这点就通了，看下面这张图片：<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.neyt0nue3cg.webp" alt="image"></p><p>对于a和b两个输入，当都是1，也就是true的时候，通过简单两个单元，形成了两个信号，其中xor是或与，用于计算最低位的数据，and用于计算较高位的数据，我们又知道在二进制中1+1&#x3D;10，其中1就是and位的值，0就是xor位置的值，对于为什么可以这么计算呢，视频中也讲解了相关的原因，可以说是非常友好了：<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.7dtmufvf2700.webp" alt="image"></p><p>  我们看前三位，关于异或这个逻辑，上面三行相加都与二进制的运算是相同的，唯独第四位，虽然末尾相同，但是有一位丢掉了，我们就用and位来承接，而前面三种情况呢，由于总是有一个数字是0，所以and总是0，这样这两个逻辑就简单的可以进行一位数据的相加了，相减其实大概上逻辑差不多。其实这里说上一句，and和xor这样的逻辑运算也是通过晶体管进行简单的搭建的，其实很简单，and，有两个输入，一个输出吗？就做成串联，or逻辑呢？那就是并联，就是通过这样做做成了各种各样的逻辑，在通过各种各样的逻辑对不同的数据进行运算。</p><p>  接上面的运算（就是1+1的运算），我们可以简化一下，一个叫做总和，一个叫进位，总和就是xor，进位就是and。当然了只能进行这样的简单计算不足以满足我们打游戏的需求，</p><p>  对于上面的计算，我们叫做半加器，为什么呢，因为你1位二进制的运算，得到的结果确是两位的，那多出来的一位怎么办呢？总不能仍了吧，于是，就有了下面的配置，全加器，就是可以全部显示结果的一个‘器’：<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.3vns9z8xxss0.webp" alt="image"></p><p>  简单来说，半加器只是输出总和，也就是后面的位，全加器就说输出进位和总和，这样我们就可以运算了，那更高级的呢？简单，你再把这个全加器看成半加器，再对其包装成一个全加器就好了，累加的足够多，可以运算的范围也就更大<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.1ap6vernm6v4.webp" alt="image"></p><p>上面这个东西，根据图片我们也可以看出有8个这个东东，所以我们叫做8位行波进位加法器，用于运算，也就是2的8次方，范围是0到255.对于超出的运算，我们叫做溢出（overflow），会造成不可预想的灾害。</p><p>  这里介绍完了ALU的运算部分，其实还有一部分，叫做逻辑单元，用于进行检测，也是通过不同的逻辑操作，具体可以看这张图：<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.6bcqkxvj8ns0.webp" alt="image"></p><p>  这是一个检测输出结果是不是0的一个逻辑单元，对于左侧的用8个二进制表示的数，我们对于它的二进制的每一个位进行检测，如果有一个不是0，它总是会输出1，可是怎么办呢？1代表正确啊，easy，在最后加上一个not的逻辑就好了。</p><p>  好了，这就是ALU的一个大体框架了，我们通常用下面这场图片表示ALU：</p><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.5tghkytzx9s0.webp" alt="image"></p><p>  这其中有输入A，输入B，操作代码（用于告诉ALU进行什么操作），输出标识，通过它，我们可以得知ALU运算的结果，当然这个结果可以是算数的，也可以是逻辑的（判断的），这也是为什么它叫做算术逻辑基本单元的原因（guess）。by the way，上面的各种功能也是根据各种晶体管和逻辑组合的。</p><h2 id="RAM和寄存器"><a href="#RAM和寄存器" class="headerlink" title="RAM和寄存器"></a>RAM和寄存器</h2><p>  上面写了半天ALU，打了会儿王者，现在来写RAM，在我们用电脑手机工作学习游戏的时候，光会计算可不行，我们需要找到东西可以记下来一些信息，在这种背景下，人们就开始研发内存。顺便说一下，RAM是仅仅在有电的情况下储存，没电了也就没有办法储存了，由于还没有看完，以后再写持久化的储存。</p><p>  <img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.1yl9v2sn0gao.webp" alt="image"></p><p>看上面两个电路，分别储存0和1，备注，下面那个线是用于回流电流，在or的情况下只要a有一次是1，那么无论它再次怎么变，都只能是1了，因为是or，这样我们就储存了1，同理，我们通过and逻辑来储存0.我们把两种电路连接起来，就做成了AND-OR锁存器（还有其他逻辑锁存器）：<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.1qbprmg8ehy8.webp" alt="image"></p><p>  我们通过上面的锁存器既可以记录1，也可以记录0，集体原理可以参考知乎上一位朋友的回答：<a href="https://www.zhihu.com/question/373693400/answer/1093469618">ANDOR锁存器</a>，简单来说就是SET和RESET都是0的时候，输出的是0，将SET设置为1，则打开了or，输出1，再将RESET设置为1，则打开了and，输出0，将两者都设置为0，就是回归原来。</p><ul><li><p>0 0输出0</p></li><li><p>1 0输出1</p></li><li><p>1 1输出0</p><p>再对这个锁存器加上两个线和一些逻辑电路，我们就形成了一个门锁：<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.4rfn3shzq2s0.webp" alt="image"></p><p>第一条线用于写自己要记录的数值，第二条线用于判断是否可以写入，如果第二条线是关闭的，那么无论第一条线怎样变，都不会写进去的，简化一下就变成了这个样子：</p></li></ul><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.736t1ag9pts0.webp" alt="image"></p><p>  当然，1个bit肯定是把不够用的，所以就出现了寄存器，就是多个锁存器结合在一起：<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.2yxrfq09q6i0.webp" alt="image"></p><p>我们通过一个线连接所有的D，也就是数据输入线，然后有选择的开启E线，也就是允许写入线，来决定寄存在哪一位上面，这样一个寄存器可以寄存8个bit，需要8+8+1+17根线，看起来还可以，但是数据一多了就会显得有点太多了，如果我们选择寄存64位，那我们总共需要129根电路，那就比较大了。当然，问题出现就一定是要解决的，于是人们想到了矩阵，当然这里不是数学意义上的矩阵，就是一个方块<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.5os7ol7wuzg0.webp" alt="image"></p><p>  像这样，我们可以贮存整整256个寄存器，通过16加16个线相连，就像一个xy坐标一样，一个固定的坐标就代表一个寄存器，对于内部，是这样的：</p><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.2483yc5fzjs0.webp" alt="image"></p><p>  这里面又多了3条线，数据线，允许写入线，允许读取线，当我们操作时，这3条线贯穿整个寄存器，但是没有旁边的两条线通过，其他的锁存器是没有办法起作用的，这样我们就通过少量线实现了较大规模的对数据的处理，比如，一个包含256锁存器的寄存器，总共需要35条线，这样不是更为方便简洁吗。</p><p>  当然，为了查找具体的地址，我们又有了专门找地址的东西，总共需要8个bit，也就是1位，前4位代表行数，后4位代表列数，这样我们就可以根据地址找到具体的位置然后进行储存了。</p><p>  但是，紧接着问题又来了，256位也还是不够，别急，根据计算机或者说是人类历史发展规律，这时候我们就需要再把这256个进行包装，再把他们看作一个一个的基本单元，再接在外面使得增加储存。<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.3z1afwzntqc0.webp" alt="image"></p><p>  左边从上到下一次是8个bit的地址，允许写入线，允许读入线，下方就是我们要储存的数据，是1位，也就是0到255，当我们要操作的时候，左边的线均匀的操作起来，把每个256的寄存器相应的地址和允许的操作打开，然后这8个bit，再一次操作进每个寄存器，也就是一共又8个寄存器，第一个寄存第一位的数字，然后第二位寄存第二位的数字，以此类推，这样，我们总共可以储存256位的数字，而每一位的范围我们前面写到过，是在0到255之间，这样内存就大大增加了。</p><p>  <img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.uk5kn0g26ao.webp" alt="image"></p><p>我们再对其进行简单的包装一下，就变成了内存条。以上就是关于内存的非常粗略的知识。</p><h2 id="CPU："><a href="#CPU：" class="headerlink" title="CPU："></a>CPU：</h2><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.33f8r1zzhny0.webp" alt="image"></p><p>  总的来说，CPU就是中间的那个东西，用来操作左侧的ALU进行计算，右侧的内存用于对数据进行处理，上方的寄存器，也是用于对数据进行处理，说一下，我们看CPU这个东西，上面的数字用来找地址，前面是寄存器还是后面是寄存器我也忘了，不过不重要，知道它是用来找地址的就好，下面的数字是来帮助它看懂指示，我们将指示进行代码话，因为计算机只能看懂0和1，所以我们到了底层也只能通过指示二进制话告诉它具体的操作。下面的东西用于控制CPU的运行速率，告诉CPU时间到了，执行下一个程序吧（就是酱紫），我们通常说的超频，低频就是与它有关，超频让他干活快一点，不过容易累死，低频就是慢一点。这样省电。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  关于CPU，以前总是感觉很奇妙，最近观看关于计算机比较底层的视频，有了一点理解。&lt;/p&gt;
&lt;p&gt;说实话，对于CPU，我以前简单的认为它是算术逻辑单元（ALU），其实这是错误的，关于讲解CPU之前，我们要先了解两个东东：ALU和内存&lt;/p&gt;
&lt;h2 id=&quot;ALU：&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sqli-34</title>
    <link href="https://huaerjiejue.github.io/2023/01/30/sqli-34/"/>
    <id>https://huaerjiejue.github.io/2023/01/30/sqli-34/</id>
    <published>2023-01-30T11:09:21.000Z</published>
    <updated>2023-01-30T11:16:29.157Z</updated>
    
    <content type="html"><![CDATA[<p>  这关是基于post类型的宽字节绕过，具体和url差不多，可以参考<a href="https://blog.csdn.net/weixin_39934520/article/details/105896415">这篇文章</a>讲解的非常详细，这里简单的加以概括说明</p><p>   get与post提交数据的区别：get型直接以url类型提交，post是全部当作文本处理，简单说就是，同样是要提交%27（单引号的url编码格式），get型直接当作url编码处理，而post是把%27看作纯文本，又将%27进行了一次url编码变成%2527，也是因为这个原因，直接在网页上操作有一定的阻挠，可以使用burpsuite进行修改，或者火狐的hackbar。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  这关是基于post类型的宽字节绕过，具体和url差不多，可以参考&lt;a href=&quot;https://blog.csdn.net/weixin_39934520/article/details/105896415&quot;&gt;这篇文章&lt;/a&gt;讲解的非常详细，这里简单的加以概括说明&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sqli-32</title>
    <link href="https://huaerjiejue.github.io/2023/01/27/sqli-32/"/>
    <id>https://huaerjiejue.github.io/2023/01/27/sqli-32/</id>
    <published>2023-01-27T10:48:31.000Z</published>
    <updated>2023-01-29T07:05:32.515Z</updated>
    
    <content type="html"><![CDATA[<p>  less-32，33，这关是宽字节绕过。</p><p>首先，我们输入id&#x3D;1，回显正常。</p><p>然后，id&#x3D;1后面加上单引号，发现被使用了魔法函数：</p><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.6g4y9or3dt40.webp" alt="image"></p><p>，不仅单引号，斜杠，反斜杠也是如此。代码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_addslashes</span>(<span class="params"><span class="variable">$string</span></span>) </span>&#123;    </span><br><span class="line">    <span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/&#x27;</span>. <span class="title function_ invoke__">preg_quote</span>(<span class="string">&#x27;\\&#x27;</span>) .<span class="string">&#x27;/&#x27;</span>, <span class="string">&quot;\\\\\\&quot;</span>, <span class="variable">$string</span>);          <span class="comment">//escape any backslash    </span></span><br><span class="line">    <span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/\&#x27;/i&#x27;</span>, <span class="string">&#x27;\\\&#x27;&#x27;</span>, <span class="variable">$string</span>);                               <span class="comment">//escape single quote with a backslash    </span></span><br><span class="line">    <span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/\&quot;/&#x27;</span>, <span class="string">&quot;\\\&quot;&quot;</span>, <span class="variable">$string</span>);                               <span class="comment">//escape double quote with a backslash    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$string</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  先解释一下源码，拿单引号举例子<code>&#39;/\&#39;/i&#39;</code>单引号用于包围，两个&#x2F;同样用于包围，其实不只是斜杠，其他的两个相同的符号都可以，i表示不区分大小写，<code>\&#39;</code>前面的反斜杠用于转义，表示一个单引号。</p><p>​    下面说一下宽字节注入原理，MySQL 在使用 GBK 编码的时候，会认为两个字符为一个汉字，例如 <code>%aa%5c</code> 就是一个 汉字。因为过滤方法主要就是在敏感字符前面添加 反斜杠 <code>\</code>，所以这里想办法干掉反斜杠即可。</p><p>​    了解了原理，下面构造payload，</p><pre><code>http://127.0.0.1/sqli-labs-master/Less-32/?id=1%df&#39;union select 1,2,3 --+</code></pre><p>​    回显正常，但是仍然是id&#x3D;1时候的信息，说明中文汉字对于这个数据查询的时候被忽略了，将id&#x3D;1换成其他不存在的数值就好了。<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.2tx9zs1ygho0.webp" alt="image"></p><p>执行成功，接下来就吃西瓜了。</p><p>​    这道题到这里就截至了吗？其实没有，想一想，你可以成功绕过前面的单引号，是因为数据库对于你前面的乱码是忽略不计的，但是后面查询的时候呢？</p><p>  例如，查询表名，后面的security需要用单引号包含起来，这时候如果还是用宽字节绕过，显示的乱码就会影响数据库的查询，这种情况下‘security’可以用database（）代替，从而绕过，不过我推荐另一种方法，就是url编码，想一想，表名可以用database（）绕过，那么列名呢？查询列名的时候可是没有代替的呀，这时候，我们把表名用url编码一下，浏览器处理 的时候，对于这两个是看成同种东西对待的，因此就可以解决后面需要单引号这个问题了。</p><p>  这里接下来有个小问题，当我们对‘users’进行url编码的时候，浏览器是报错的<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.4xa24ytzumi0.webp" alt="image"></p><p>  为什么呢？前面说过，浏览器对于正常值和url编码是同等看待的，我们看下面的报错就知道了：</p><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.49clirp0w2g0.webp" alt="image"></p><p>可以看到，对于浏览器来说，你输入的，同样没变，url编码只是适用于一些关键字的绕过。</p><p>这时，我们只需要简单的对上面的东西进行16进制编码就可以了</p><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.2u96wig0tpw0.webp" alt="image"></p><p>绕过成功了，为什么呢，我们根据下面显示的内容就可以看到，其实16进制转换后，服务器后端看到的就是上面的内容，根本没有敏感符号，也就不会阻拦了。</p><p>  这里想根据自己的理解强行解释一下，当然肯定有不对的地方，也算是一点拙见吧，</p><p>  首先，问题1，为什么使用16进制呢？使用bash64等不行吗？  不行，16进制是编码，bash64等是加密，也就是说，你转换成16进制，数据库查询的时候仍然可以查询到，而如果加密了，后面没有解密，数据库肯定查询不到加密后的数据。</p><p>  其次，问题2，为什么仅对表名进行加密，前面的也加密可以吗？  也不可以，前面的叫做关键字，后端数据库连干什么都不知道，更不用说返回信息了，而你告诉它要干什么，只不过是把要处理的数据通过16编码一下，它还是可以查询的。而进行url编码其实是可以的，前面说过，浏览器处理原始数据和url编码后的东西是平等看待的。</p><p>  问题3，<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.6x0ytf7g87g0.webp" alt="image"></p><p>我修改将q中的内容进行16进制编码为什么不行？，答，这他妈是搜索的</p><p>​    关于url编码，还要补充一下，为什么url存在编码这个东西，网上一顿查询，大概意思就是使用于非保留字符，有些字符它在url上面是有特殊含义的，如果你要使用没有特殊含义的这个字符，一个简单的方法就是使用这个特殊字符的url编码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  less-32，33，这关是宽字节绕过。&lt;/p&gt;
&lt;p&gt;首先，我们输入id&amp;#x3D;1，回显正常。&lt;/p&gt;
&lt;p&gt;然后，id&amp;#x3D;1后面加上单引号，发现被使用了魔法函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.staticaly.com/gh</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sqli-30</title>
    <link href="https://huaerjiejue.github.io/2023/01/24/sqli-30/"/>
    <id>https://huaerjiejue.github.io/2023/01/24/sqli-30/</id>
    <published>2023-01-24T03:01:31.000Z</published>
    <updated>2023-01-24T03:03:43.219Z</updated>
    
    <content type="html"><![CDATA[<p>  总的来说，这关和第29关差不多，只是把单引号换成了双引号，但是发现了一个新思路，可能作者并不是写写错了，有可能是让我们学会查找目录，我使用7kbscan就可以扫面到目录</p><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.56qqtb7aoa40.webp" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  总的来说，这关和第29关差不多，只是把单引号换成了双引号，但是发现了一个新思路，可能作者并不是写写错了，有可能是让我们学会查找目录，我使用7kbscan就可以扫面到目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.staticaly.com/gh/huae</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sqli-29</title>
    <link href="https://huaerjiejue.github.io/2023/01/23/sqli-29/"/>
    <id>https://huaerjiejue.github.io/2023/01/23/sqli-29/</id>
    <published>2023-01-23T07:55:16.000Z</published>
    <updated>2023-01-23T14:34:08.798Z</updated>
    
    <content type="html"><![CDATA[<p>​    第29关，可能是编写作者的问题或者其他，第29关如果直接进入，跟他妈没有防御一样，<img src="https://jsd.cdn.zzko.cn/gh/huaerjiejue/pic_of_myweb@master/image.3f4ypw04roe0.webp" alt="image" style="zoom: 33%;" /></p><p>直接输入id，单引号闭合，然后直接注入就好，直接爆破了，然后带着疑惑去网上查询，发现人家都是又WAF的，真奇怪，为什么我直接输入id&#x3D;1‘就不会准换页面，<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.3z9d3vf7zn80.webp" alt="image" style="zoom:33%;" /></p><p>然后看到了<a href="https://blog.51cto.com/u_15064644/3461635">一篇文章</a>发现可能是文件的问题，打开文件目录，发现这三个文件</p><p><img src="https://jsd.cdn.zzko.cn/gh/huaerjiejue/pic_of_myweb@master/image.6jqfjz6wqy40.webp" alt="image"></p><p>于是试着在less-29后面加上login.php，就有waf了，成功可以有难度的注入了。</p><p><strong>正文开始：</strong></p><p>输入id&#x3D;1，成功，</p><p>输入id&#x3D;1’，报错，转出，<img src="https://jsd.cdn.zzko.cn/gh/huaerjiejue/pic_of_myweb@master/image.iedtglz30uw.webp" alt="image" style="zoom:33%;" /></p><p>正当迷茫的时候，眼前一亮，发现有两个参考</p><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.49lczztlynm0.webp" alt="image"></p><p>​    看了一眼，emmm，看不懂，但大概讲的是http参数污染，我猜测作者可能想通过这关教程参数污染，向浏览器输入<code>?id=1 &amp;id=222 union select 1,2,3 —+</code>可惜，没有成功，通过一番改动后发现<code>?id=1&amp;id=222&#39; union select 1,2,3 --+</code>可以，为什么呢，根据后面我们可知，后端代码通过&amp;分隔语句，第一个语句后面有空格，俨然不成立，然后由于php阿帕奇数据库面对参数污染的情况下查询的是第二个参数，但是我没有协商分号，通过这两个改动，语句成功执行。<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.2eyz3gm7k05c.webp" alt="image" style="zoom:33%;" /></p><p>后面就可以愉快的注入了，报数据一气呵成。</p><p>下面通过代码说明一下绕过原理：</p><p>前面大抵是无差别的，就是多了两个函数，<code>java_implimentation</code>和<code>whitelist</code>,</p><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.747514oyn8w0.webp" alt="image"></p><p>​    然后接着向下查找这两个函数，发现代码如下</p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.3yqupbctc0o0.webp" alt="image" style="zoom: 50%;" /><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.6esi9vsvh9c0.webp" alt="image" style="zoom: 50%;" /><p>​    上面第一个函数就是与传入进来的数据进行比较，判断是否是纯数字，如果是就通过，如果并不是就转到报错界面，第二个函数就是把传入的数字通过&amp;进行划分，放进数组里，找到前面是id的一个元素，返回这个元素id&#x3D;后面的东西，而主函数就是将这个分离出来的东西放入whitelist进行检测，如果没有错误就会执行。</p><p>我们的构造语句就是通过在语句中加入&amp;进行划分，java_函数通过第一个id&#x3D;1后因为break后面就不进行检测了，然后传出的数据自然可以通过whitelist检测，顺利通过后再将原来的语句放入数据库进行查询，而阿帕奇php的数据库查询的确实后面的参数，这样，我们就绕过了防御并进行了入侵。</p><p>​    简单说明一下，不同的服务器，不同的语言对于参数污染的处理不同，渗透测试的时候可以依据下面的数据，<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.2s6cxefbit80.webp" alt="image" style="zoom: 67%;" /></p><p>通过上面的内容我们可以对于不同的情况进行分析，当然，没有的数据也不要慌，试一下就好了。简单说明一下，<code>java_implimentation()</code>是用于模仿参数污染，当输入不同参数的时候以&amp;进行分割，但是这个函数的问题就是它划分完之后找到一个id就break，没有多次进行验证，这样就导致了hpp（参数污染）成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    第29关，可能是编写作者的问题或者其他，第29关如果直接进入，跟他妈没有防御一样，&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/huaerjiejue/pic_of_myweb@master/image.3f4ypw04roe0.web</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sqli-27</title>
    <link href="https://huaerjiejue.github.io/2023/01/19/sqli-27/"/>
    <id>https://huaerjiejue.github.io/2023/01/19/sqli-27/</id>
    <published>2023-01-19T09:15:26.000Z</published>
    <updated>2023-01-20T12:20:54.676Z</updated>
    
    <content type="html"><![CDATA[<p>  今天发现个好玩的情况，照常注入，过滤了union，select，同样通过多次拼写成功绕过，然后我输入测试语句：<code>？id=13333%27ununionion%a0seseselectlectlect%a01,group_concat%28table_name%29,3%a0from%a0information_schema.tables%a0where%a0table_schema=%27security%27||%271</code></p><p>下面确实爆出数据了，但是我却没有输出相应的回显，输出了这个东西： CHARACTER_SETS （后面还有好多，但是太丑了，就不都弄出来了），这是个什么?网上一查，这是information_schema下面的表，好家伙，我不是具体指定表了吗，为什么还会输出上面的表，仔细对比发现也没有错误啊，终于，我把目光锁定到后面的||上，将它改一改，改成；%00（不得不说，真是个好东西），发现回显正确，果然是后面或者的问题，然后找chatgpt谈一谈，了解了个大概，就是当我们如上面那么写的时候，sql就会认为这是一个判断，只要是非0的东西，就是1，本来就是或者了，再加上后面就是1，所以这玩意显示个1，因此，sql也就不会按照我想要的方式查询了，我猜想，后端代码可能将<code>where%a0table_schema=%27security%27||%271</code></p><p>看作一个语句了，恰巧返回1，也就可以解释为什么返回information_chema的表了，可以，开心的一天。</p><p>​    吐槽一次，这样好丑，仿佛有种字不好看的日记的形式，主要是不想捣鼓图库，哎，懒癌没救了。没准哪一天真的弄了一个呢。</p><p>  by the way，绕过union，select可以混合大小写绕过</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  今天发现个好玩的情况，照常注入，过滤了union，select，同样通过多次拼写成功绕过，然后我输入测试语句：&lt;code&gt;？id=13333%27ununionion%a0seseselectlectlect%a01,group_concat%28table_name%</summary>
      
    
    
    
    
    <category term="sqli-lab" scheme="https://huaerjiejue.github.io/tags/sqli-lab/"/>
    
  </entry>
  
  <entry>
    <title>sqli-26a</title>
    <link href="https://huaerjiejue.github.io/2023/01/18/sqli-26a/"/>
    <id>https://huaerjiejue.github.io/2023/01/18/sqli-26a/</id>
    <published>2023-01-18T11:15:50.000Z</published>
    <updated>2023-01-19T08:58:46.610Z</updated>
    
    <content type="html"><![CDATA[<p>​    我决定了，以后就直接写题目了，这样比较只管，还简单，今天是26a</p><p>​    这关有点不寻常，它首先关闭了报错显示，然后过滤了一些符号，这就导致我在测试参数闭合的时候手忙脚乱，以至于昨天心烦意乱的上床了。</p><p>​    根据源码，我们得知，这关闭合情况是单引号和括号，但是无论我怎么测试都测试不出来那个括号。</p><p>​    其实网上有相应的方法，但是，今天我才看到网络世界的丰富多彩，真他妈一塌糊涂啊，有的上来直接看源码，然后直接闭合，有的根本不对，有的明明双引号也可以，但就是忽略，属实让我想狠狠吐槽一下子。下面说一下我在网上好不容易找到的两种测试闭合的方式，其中第一种实在是太牛了。</p><h4 id="First"><a href="#First" class="headerlink" title="First:"></a>First:</h4><p><code>id=2&#39;&amp;&amp;&#39;1&#39;=&#39;1</code></p><p>​    若查询语句为<code>where id=&#39;$id&#39;</code>，查询时是<code>where id=&#39;2&#39;&amp;&amp;&#39;1&#39;=&#39;1&#39;</code>，结果是<code>where id=&#39;2&#39;</code>，回显会是<code>id=2</code>。</p><p>​    若查询语句为<code>where id=(&#39;$id&#39;)</code>，查询时是<code>where id=(&#39;2&#39;&amp;&amp;&#39;1&#39;=&#39;1&#39;)</code>，MySQL 将<code>&#39;2&#39;</code>作为了 Bool 值，结果是<code>where id=(&#39;1&#39;)</code>，回显会是<code>id=1</code>。</p><p>​    这属实是聪明了，不是吗？就是不知道双引号的时候怎么办😖😖😖😖</p><h4 id="Second"><a href="#Second" class="headerlink" title="Second:"></a>Second:</h4><p>;%00</p><p>​    说实话，这个我目前还不知道为什么，但他就是可以区分出来括号和双引号，你说气不气</p><p>​    当输入1’；%00的时候，没有回显，表示有错误</p><p>​    当输入1‘”；%00的时候，同样没有回显，表示有错误</p><p>​    当输入1’）；%00的时候，回显正常，表示ok</p><p>这个确实听迷惑，但也可以，emmmmmm，离谱</p><p>———————一天后——————————</p><p>我想明白了，我终于想明白了，php语句和c语言等一样，后面都与要分号；，而%00又使用于00截断，这里就是相当于给当前语句加上一个分号并且把后面的东西截断一下，这不就是相当于注释掉了吗，总的来说，这也是个好办法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    我决定了，以后就直接写题目了，这样比较只管，还简单，今天是26a&lt;/p&gt;
&lt;p&gt;​    这关有点不寻常，它首先关闭了报错显示，然后过滤了一些符号，这就导致我在测试参数闭合的时候手忙脚乱，以至于昨天心烦意乱的上床了。&lt;/p&gt;
&lt;p&gt;​    根据源码，我们得知，这</summary>
      
    
    
    
    
    <category term="sqli-lab" scheme="https://huaerjiejue.github.io/tags/sqli-lab/"/>
    
  </entry>
  
  <entry>
    <title>sql注入笔记4</title>
    <link href="https://huaerjiejue.github.io/2023/01/15/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B04/"/>
    <id>https://huaerjiejue.github.io/2023/01/15/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B04/</id>
    <published>2023-01-15T13:23:37.000Z</published>
    <updated>2023-01-16T13:53:28.882Z</updated>
    
    <content type="html"><![CDATA[<p>  哎，最近好忙，一堆事，但是学习还是不能丢下的，今天是sqllab-26，这关是过滤了空格，注释符，and，or，好家伙，这么丧心病狂可不好。</p><p>  首先，先列一下常见的绕过方式：</p><ol><li>双写绕过</li><li>大小写绕过</li><li>编码绕过，如：hex || URL</li><li>注释符绕过，如：&#x2F;<em>!select</em>&#x2F;</li><li>替换：如 and 可替换为 &amp;&amp; ,or 可替换为 ||，这两个字符也可以转换成相应的url格式</li><li>空格的话我们可以 url 绕过：%a0 || %0b 等等，过滤字符我们可以用 and || or 替代</li></ol><p>补充一点，空格还可以通过（）绕过，这关就是酱紫，还是写个例子吧：</p><p><code>id=1 and 1=1</code></p><p>这关是有单引号，还不可以使用注释符，所以就手工加上单引号呗，然后and要双写或者使用&amp;&amp;，空格要使用（），所以一个成功的payload如下：</p><p><code>id=-1‘&amp;&amp;(1=1)||&#39;1&#39;=&#39;1</code></p><p>其中and 1&#x3D;1就可以插入恶意语句了，就可以了，例如</p><p><code>?id=-1&#39; || updatexml(1,concat(0x7e,database()),1) || &#39;1&#39;=&#39;1</code></p><p>下面是这关的过滤函数，说实话，真的有的难，哭了</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">`<span class="function"><span class="keyword">function</span> <span class="title">blacklist</span>(<span class="params"><span class="variable">$id</span></span>) </span>&#123;      <span class="variable">$id</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/or/i&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);      <span class="comment">//strip out OR (non case sensitive)     </span></span><br><span class="line">                                <span class="variable">$id</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/and/i&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);      <span class="comment">//Strip out AND (non case sensitive)      </span></span><br><span class="line">                                <span class="variable">$id</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[\/\*]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);      <span class="comment">//strip out /*      </span></span><br><span class="line">                                <span class="variable">$id</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[--]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);      <span class="comment">//Strip out --       </span></span><br><span class="line">                                <span class="variable">$id</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[#]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);      <span class="comment">//Strip out #      </span></span><br><span class="line">                                <span class="variable">$id</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[\s]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);      <span class="comment">//Strip out spaces      </span></span><br><span class="line">                                <span class="variable">$id</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[\/\\\\]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);      <span class="comment">//Strip out slashes      return $id; &#125;`</span></span><br></pre></td></tr></table></figure><p>我感觉，应该找个时间把相应的sql语句和一些绕过做一些总结，可是至少需要把靶场都跑玩吧。</p><p>又又又来补充了，<a href="https://blog.csdn.net/kukudeshuo/article/details/114707072">sql-26</a>这个网站作者给了一段python代码用来跑一共有多少种可以代替空格的字符，代码较为简单，但是也值得学习一下，毕竟咱现在是菜鸟，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">    <span class="comment">#print(i)</span></span><br><span class="line">    code = <span class="built_in">hex</span>(i).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(code) &lt; <span class="number">2</span>:</span><br><span class="line">        code = <span class="string">&quot;0&quot;</span> + code</span><br><span class="line">    code_0x = <span class="string">&quot;%&quot;</span> + code</span><br><span class="line">    <span class="comment">#print(code_0x)</span></span><br><span class="line">    url = <span class="string">&quot;http://127.0.0.1/sql1/Less-26/?id=1&#x27;&quot;</span> + code_0x + <span class="string">&quot;%26%26&quot;</span> + code_0x + <span class="string">&quot;&#x27;1&#x27;=&#x27;1&quot;</span></span><br><span class="line">    r = requests.get(url=url)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;Dumb&quot;</span> <span class="keyword">in</span> r.content.decode(<span class="string">&quot;utf-8&quot;</span>,<span class="string">&quot;ignore&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span>(code_0x) </span><br></pre></td></tr></table></figure><p>这段代码张主要有两个东西要学习一下吧，也是我不知道的地方</p><p>第一点，是<code>code = hex(i).replace(&#39;0x&#39;, &#39;&#39;)</code>这个东东，hex（）是python中的一个函数，用于转换成16进制，后面的replace是用来去除16进制数前面的标识符0x的。</p><p>第二点，是 &#96;&#96;if “Dumb” in r.content.decode(“utf-8”,”ignore”)&#96;这其中，r.content用于显示响应内容的字节格式，r.content.decode…是对字节对象转换成字符串对象，后面的ignore意味着响应中的任何无效字节都将被忽视，不会导致错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  哎，最近好忙，一堆事，但是学习还是不能丢下的，今天是sqllab-26，这关是过滤了空格，注释符，and，or，好家伙，这么丧心病狂可不好。&lt;/p&gt;
&lt;p&gt;  首先，先列一下常见的绕过方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;双写绕过&lt;/li&gt;
&lt;li&gt;大小写绕过&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>gameshell命令总结</title>
    <link href="https://huaerjiejue.github.io/2023/01/13/gameshell%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>https://huaerjiejue.github.io/2023/01/13/gameshell%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-13T09:23:10.000Z</published>
    <updated>2023-01-31T11:47:05.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="game-shell命令总结"><a href="#game-shell命令总结" class="headerlink" title="game shell命令总结"></a>game shell命令总结</h1><p>最近迷上了gameshell这个小游戏，总体来说挺不错的，在玩游戏的同时就可以学习linux的命令，所以写一篇博客可以记录一下，估计当我全部通关后应该挺多的吧。</p><p>[TOC]</p><h2 id="mission-1-14"><a href="#mission-1-14" class="headerlink" title="mission 1~14:"></a>mission 1~14:</h2><ul><li>cat：显示文本信息</li><li>cd：进入文件，单纯的cd是回到根目录，~代表根目录，加上。。是返回上一级目录，加上-是返回上次操作时的目录</li><li>ls：列出当前文件夹中的文件，-a是全部显示，包括隐藏掉的，医保linux文件以‘.’开头的文件是隐藏的，-l列出信息的同时列出创建时间等细节</li><li>cal：列出日历信息，加上年份时列出某具体一年的日历</li><li>alias：简化命令，例如：<code>alias la=&#39;ls -a&#39;</code>是将后面的命令包装成前面的命令</li><li>rm:：移除文件</li><li>mv：移动文件，相当于剪切，<code>mv FILE dir</code>FILE是要移动的文件，dir是移动的目的文件夹</li><li>mkdir：make direction 创建文件夹</li><li>pwd：列出当前文件位置</li></ul><h2 id="mission-15"><a href="#mission-15" class="headerlink" title="mission 15:"></a>mission 15:</h2><ul><li>介绍了一下nano编辑器的简单使用，可以用于创建文件并写入文件。</li></ul><p>  ​    o是保存，x是退出，当然编辑器上有提示</p><h2 id="mission-16"><a href="#mission-16" class="headerlink" title="mission 16:"></a>mission 16:</h2><ul><li>使用了一下 alias journal&#x3D;’nano ~&#x2F;Forest&#x2F;Hut&#x2F;Chest&#x2F;journal.txt’来在任意位置使用</li></ul><hr><p>这里有一个小插曲，介绍了re这个文件，例如bash命令下是.bashrc，zsh命令下是.zshrc，用于记录自己的alias命令，以防止自己忘记，当然，不是电脑帮忙记住，是要自己手动输入</p><hr><h2 id="mission17"><a href="#mission17" class="headerlink" title="mission17:"></a>mission17:</h2><ul><li>nothing,it is trully a game,😂😂</li></ul><h2 id="mission-18"><a href="#mission-18" class="headerlink" title="mission 18:"></a>mission 18:</h2><p>了解了一个有趣的linux命令，xeyes，会出现一只小眼睛一直看着你的鼠标，非常有意思，然后如果你想让它后台运行，也就是不妨碍你继续工作，可以使用 xeyes &amp;这个命令，它就会后台运行，然后，ctrl+c就是退出。下面再列举一些有趣的linux命令：</p><ol><li><p>xeyes，出现一双眼睛</p></li><li><p>rev，颠倒输入的字符，如果输入asd，输出dsa</p></li><li><p>sl，会出现一辆火车从屏幕右边开往屏幕左边</p></li><li><p>asciiview，给它一个照片，它会输出用二进制表示的相应照片，单数需要先安装</p><p>aview，然后安装imagemagick，最后使用即可</p></li><li><p>aafire，在终端放一把火，安装libaa-bin，运行即可</p></li><li><p>cmatrix，字符雨，想象黑客帝国，同样，安装cmatrix，然后运行</p></li><li><p>boxes，使用字符型图形包装文字，具体参考<a href="(https://zhuanlan.zhihu.com/p/52558937)">boxes</a></p></li></ol><h2 id="mission-19-amp-20"><a href="#mission-19-amp-20" class="headerlink" title="mission 19&amp;20:"></a>mission 19&amp;20:</h2><ul><li>ls -R,列出当前目录的文件以及文件中的文件，就是把这个文件中的所有东西都列举出来。</li><li>tree，同ls-r类似，就是会用树状图的形式列举出来</li></ul><p> 以上两个命令对于找文件非常好用</p><h2 id="mission-21："><a href="#mission-21：" class="headerlink" title="mission 21："></a>mission 21：</h2><ul><li><p>find，用于查找文件</p><p>主要参数： -name，指定名字，必须完全一样，不然就需要*和？</p><p>​                   -iname，指定名字，但忽略大小写</p><p>​                    -size，指定大小，其中有 b块 c字节 w字 k千字节 M兆字节 G吉字节，注意大小写</p><p>具体可以看<a href="https://wangchujiang.com/linux-command/c/find.html#!kw=head">find 命令，Linux find 命令详解：在指定目录下查找文件 - Linux 命令搜索引擎 (wangchujiang.com)</a>需要外网。</p></li><li><p>man，<strong>man命令</strong> 是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息。</p></li></ul><h2 id="mission-22："><a href="#mission-22：" class="headerlink" title="mission 22："></a>mission 22：</h2><ul><li>head，用于print文件里的内容，通过-n可以指定输出几行，与cat的区别是，cat是展示全部，head是展示前几行，默认是输出10行，-c参数用于指定字节，后面的number可以有一个乘数后缀，例如1024*1024之类的。也可以使用二进制前缀</li></ul><h2 id="mission-23"><a href="#mission-23" class="headerlink" title="mission 23:"></a>mission 23:</h2><ul><li>tail，同head差不多，不同的是tail展示后几行，默认也是10行，也可以通过-n等参数进行控制</li></ul><h2 id="mission-24"><a href="#mission-24" class="headerlink" title="mission 24:"></a>mission 24:</h2><ul><li>cat FILE1 FILE2 FILE3 FILEn，依次顺序输出</li></ul><h2 id="mission-25"><a href="#mission-25" class="headerlink" title="mission 25:"></a>mission 25:</h2><ul><li>|(管道)，用于将两个进程相联系，举个例子：<code>COMMAND1 | COMMAND2</code> 将命令1的输出当作命令2的输入，这一关使用的是这样的，因为cat可以同24关一样一块输出，但是tail不能使用多个文件，但是cat不能去掉标题，所以可以使用cat将两个文件先结合起来，然后通过tail去除标题，<code>cat page_01 page_02 | tail -n 16</code></li></ul><h2 id="mission-27"><a href="#mission-27" class="headerlink" title="mission 27:"></a>mission 27:</h2><ul><li>ps，列出正在进行的进程</li><li>kill，发送信号到进程</li><li>clear(control -c)，清除界面</li></ul><h2 id="mission-28"><a href="#mission-28" class="headerlink" title="mission 28:"></a>mission 28:</h2><ul><li>kill，-l 列出信号，-s 信号名称，使用如下：</li></ul><p>​     <img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.153c88jdzn34.webp" alt="image"></p><p>常见的信号以及名称如下：</p><p><img src="D:\hexo-jason-blog\source_posts\assets\image-20230126191102735.png" alt="image-20230126191102735"></p><p>这里推荐一下一个平台，包含绝大部分linux<a href="https://wangchujiang.com/linux-command/">命令</a>，虽然好像也没有人看吧。。。。。</p><ul><li>PID，进程ID</li></ul><h2 id="mission-29"><a href="#mission-29" class="headerlink" title="mission 29:"></a>mission 29:</h2><ul><li>pstree，以树状图方式展示进程之间的派生关系，-p PID 显示程序识别码，  pstree $$ 以树状图展示，同时显示脚本运行的进程ID</li></ul><h2 id="mission-31"><a href="#mission-31" class="headerlink" title="mission 31:"></a>mission 31:</h2><ul><li><p>&gt;，重定向输出，COMMAND &gt; FILE 将命令的输出结果输出到文件，具体见使用：</p><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.7bl39zjxfn00.webp" alt="image"></p></li></ul><p>其实大于小于号都一样，看箭头指向那边那边就输出，但是符号左边一定是COMMAND右边一定是FILE。</p><p>ps，第32关有亿点点难，头一次没解决关卡退出，啊啊啊啊，明天一定要做出来。</p><h2 id="mission-32"><a href="#mission-32" class="headerlink" title="mission 32:"></a>mission 32:</h2><ul><li>less,一种查看文本的方式，一般情况下，cat查看是全部查看，这样面对一些大的文件的时候就会比较占用资源，less，就是部分部分的看，通过pgup,pgdn,space,q来操纵着看，还可以通过&#x2F;来搜索，这样既比较简洁，又不会对内存有较大的需求，当然这关虽然给了这个命令，但是通过这个关卡根本没有用到这个命令。无语了家人们。</li></ul><p>下面是通关的语句，<img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.604jkk1caa80.webp" alt="image"></p><p>保存到inventory.txt文件的内容如下，</p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.1zhdfpxwh4m8.webp" alt="image"  /><p>这里说明一下，ls本质是用于显示目录内容列表的，也就是说ls后面应该跟上一个文件夹，或者干脆不加，而ls后面单纯地加上文件，它就只会单纯地显示这个文件的名字，这也就是为什么保存在inventory.txt里面的是这些文件里面的名字而不是他们的内容了，如果要加入内容，可以这么写，</p><p><code>less gri*&gt;Drawer/inventory.txt</code></p><h2 id="mission-33"><a href="#mission-33" class="headerlink" title="mission 33:"></a>mission 33:</h2><ul><li><p>grep，查找相应的信息，注意grep是从文件中查找，find是查找文件，当然，grep也有相应的快捷指令，-i（不区分大小写），-l（列出文件名称，不包含内容），—color（将查询的字符串用颜色标出，以便更好区分）</p><p>常用格式  <code>grep -key STRING FILE</code></p></li></ul><p>补充一下：</p><ol><li>一般文件有两种输出，一种是standard output（标准输出），也写作“stdout”，也就是内容，一种是error output（标准错误），也写作“stderr”，1&#x3D;&gt;stdout,2&#x3D;&gt;stderr,0&#x3D;&gt;stdin（标准输入）,这些数字用于linux重定向输出的时候，用于夹在重定向符号前面。而&amp;是一个描述符，1&gt;&amp;2表示把标准输出重定向到标准错误，2&gt;&amp;1表示把标准错误重定向到标准输出，&amp;&gt;FILE意思是把标准输出和标准错误输出到文件。一般来说，不加文件描述符，系统默认标准输出。</li><li>对于重定向符号，不只是简单的有&lt; &gt;，还有&lt;&lt; &gt;&gt;，前者代表重定向输出，后者代表添加，意思是后者不会该表文件的内容，直接在后面添加内容，而前者是要全部覆盖的。</li><li>重定向符号 COMMAND &gt; FILE，管道符COMMAND|COMMAND</li><li>&#x2F;dev&#x2F;null，这是一个linux的空设备文件，任何写在里面的东西都会消失，通常与文件的输出结合在一起使用。而且，这个文件在问价中找不到，但是直接使用就好。</li></ol><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.5mosftmmdl00.webp" alt="image" style="zoom:80%;" /><p>这关的代码<code>grep gsh gri* -i -l 2&gt;/dev/null</code>就是匹配gri*的文件，查找是否有gsh这个文本，其中不区分大小写，同时不打印文件内容，同时将标准错误放到&#x2F;dev&#x2F;null中，因为有些文件会因为权限不足无法访问，将标准错付放走会向上面的一样只显示标准输出了，从而没有错误信息，如果文件描述符没有或者为1，那么最终显示的就全都是错误信息了。</p><h2 id="mission-34"><a href="#mission-34" class="headerlink" title="mission 34:"></a>mission 34:</h2><ul><li>.&#x2F;，执行可执行程序</li></ul><p>​    第34关光是找到key还不够，还有两步，第一步，将key导入到一个文件中         <code>./merlin2&gt;merlin_stderr.txt</code>（这里stderr是key）</p><p>​    第二步，通过文件验证，<code>gsh check&lt;merlin_stderr.txt</code></p><h2 id="mission-35"><a href="#mission-35" class="headerlink" title="mission 35:"></a>mission 35:</h2><ul><li><p>chmod，更改文件和目录的权限，选项，-c当文件权限更改时输出信息，-v文论文件是否更改权限都输出信息，-R对目录以及目录一下的文件均修改权限，—referene&#x3D;RFILE根据参考目录更改权限，其中u代表当前用户，g代表组用户，o代表其他用户，a代表全部yoghurt，r是读权力以及八进制数字4，w是写权力以及八进制数字2，x是执行权力以及八进制数字1</p><p>举例：</p><p>chmod g+w .&#x2F;text.log    增加组用户的写的权力</p><p>也可以通过8进制数字进行使用，</p><p>chmod u&#x3D;rwx,g&#x3D;rw,o&#x3D;r .&#x2F;text.log  与</p><p>chmod 764 .&#x2F;text.log等效，其中7&#x3D;4（r）+2（w）+1（x）</p></li></ul><h2 id="mission-36-37"><a href="#mission-36-37" class="headerlink" title="mission 36 37:"></a>mission 36 37:</h2><p>  正常查找文件该权限，直接过。</p><h2 id="mission-38"><a href="#mission-38" class="headerlink" title="mission 38:"></a>mission 38:</h2><p>  这关实在maze中所有文件中找到文件中包含ruby的字符串的文件，并将其移至chest中，一开始我想的是使用管道查询并操作，语句是这样的：<code>find -type f|grep ruby</code>，发现没有，这里的管道前面的命令列举出一堆文件，然后我使用<code>find -type f|cat</code>发现输出的只是这堆文件，并没有输出文件内容，后来根据youtube上面的视频，发现这样可以：<code>find . -type f  -exec grep ruby &#39;&#123;&#125;&#39; \;</code>于是查询了一下，是exec和管道符的区别，对于exec来说，它是对于查到的每一个文件都进行后面的操作，‘{}’代表文件名，而管道|只是对于文件名称进行操作，所以才会出现cat出来的只是文件名的情况。</p><p>“find . -type f -exec grep ruby ‘{}’ ;” 和 “find . -type f | grep ruby” 有如下不同：</p><ol><li>管道命令（”|”）和 exec 选项（”-exec”）的区别：</li></ol><ul><li>管道命令（”|”）是将 find 命令的输出作为 grep 命令的输入，grep 命令对 find 命令的所有输出进行搜索。</li><li>exec 选项（”-exec”）在 find 命令每次找到一个文件时，执行 grep 命令一次。</li></ul><ol start="2"><li>结果不同：</li></ol><ul><li>管道命令（”|”）只输出包含 “ruby” 的文件名，并不显示包含 “ruby” 的行。</li><li>exec 选项（”-exec”）输出每个文件中包含 “ruby” 的所有行。</li></ul><p>事实证明，xargs也可以：<code>find -type f|xargs grep ruby &quot;ruby&quot;</code></p><p>关于exec和xargs，exec是对每一个文件都开启一个进程，这样电脑就会变慢，而xargs是统统开到一个进程里面，这样会快并且占用内存少。</p><h2 id="mission-39"><a href="#mission-39" class="headerlink" title="mission 39:"></a>mission 39:</h2><p>  无</p><h2 id="mission-40"><a href="#mission-40" class="headerlink" title="mission 40:"></a>mission 40:</h2><ul><li>grep -v</li></ul><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.2op42bemx2a0.webp" alt="image"></p><p>  先找到所有普通文件，然后在这里通过xargs查找含有关键字King的文件，再在显示的文本中显示出没有PAID的文本，最后计算就好</p><h2 id="mission-41"><a href="#mission-41" class="headerlink" title="mission 41:"></a>mission 41:</h2><ul><li>wc，统计文件的字节数、字数、行数。-c  统计字节数，或–bytes：显示Bytes数。 -l  统计行数，或–lines：显示列数。 -m  统计字符数，或–chars：显示字符数。 -w  统计字数，或–words：显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。 -L # 打印最长行的长度，或–max-line-length。</li></ul><h2 id="mission-41-1"><a href="#mission-41-1" class="headerlink" title="mission 41:"></a>mission 41:</h2><ul><li><p>tr STR1 STR2，转换字符，举个例子，</p><p>echo “HELLO WORLD” | tr ‘A-Z’ ‘a-z’<br>hello world着就是将大写字母转换成小写字母</p><p>当然，还可以进行删除，使用参数-d</p><p>echo “hello 123 world 456” | tr -d ‘0-9’<br>hello  world </p><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.6hp6amp6ohc0.webp" alt="image"></p></li></ul><h2 id="mission-43"><a href="#mission-43" class="headerlink" title="mission 43:"></a>mission 43:</h2><p><img src="https://cdn.staticaly.com/gh/huaerjiejue/pic_of_myweb@master/image.3379mp3bfey0.webp" alt="image"></p><p>终于完成所有的关卡了，激动，感动，加油。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;game-shell命令总结&quot;&gt;&lt;a href=&quot;#game-shell命令总结&quot; class=&quot;headerlink&quot; title=&quot;game shell命令总结&quot;&gt;&lt;/a&gt;game shell命令总结&lt;/h1&gt;&lt;p&gt;最近迷上了gameshell这个小游戏，总体</summary>
      
    
    
    
    
    <category term="linux gameshell" scheme="https://huaerjiejue.github.io/tags/linux-gameshell/"/>
    
  </entry>
  
  <entry>
    <title>sql注入笔记3</title>
    <link href="https://huaerjiejue.github.io/2023/01/12/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B03/"/>
    <id>https://huaerjiejue.github.io/2023/01/12/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B03/</id>
    <published>2023-01-12T11:09:44.000Z</published>
    <updated>2023-01-14T13:31:14.043Z</updated>
    
    <content type="html"><![CDATA[<p>今天是sqllab-25关，总体来说是比较简单的。首先，根据题目‘your or &amp; and is mine’可知作者在创作这关的时候把or和and处理了，好在作者比较贴心地在下面给出了你输入的语句在后台的显示情况。</p><p>首先我们可以测试一下，输入单引号（‘），发现报错，可以得知id由单引号闭合，然后输入and 1&#x3D;2，我们根据显示发现我们的代码到了后台变成了1&#x3D;2，说明经过后端验证，它把我们的and吞掉了，同理，根据题目，可以得知or应该也如此。</p><p>我们看一下网站代码，发现这样两个语句：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blacklist</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/or/i&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//strip out OR (non case sensitive)</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/AND/i&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//Strip out AND (non case sensitive)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得知preg_replace函数将and和or换成了null，也就是无，对应的方法也挺简单，比如我们要输入and，只需要输入anandd就好了，因为这个函数只是简单地出现了一次，所以它在它有且仅有的一次转换中，将中间的 and消除了，而因为中间的and消失了，两头的字母自然合并，组成了一个新的and，这样就成功绕过了。然后几句可以进行联合注入，报错注入等惊醒sql注入。</p><p>其实这次测试比较简单，但是我发现自己真实漏洞百出，基础实在是有点不扎实，下面写一下如何进行union查询的时候将数据一块列出，而不使用limit，毕竟懒癌晚期，没办法。成组列出数据也挺简单，只需要<code>group_concat()</code>就好，下面是具体使用这个这个函数的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure><p>说一下使用这个函数的注意事项吧，</p><p>​    1.<code>group_concat</code>后面用括号括起来要查询的具体的值</p><p>​    2.无论什么，查询值的时候要先from后where</p><p>​    3.数据库要么写database（），要么写’security‘（数据库的名字，主义要加上单引号）</p><p>​    4.from…where…语句主义要放在select整体语句的后面，不能夹在中间</p><p>然后还有一个事情，当时死活构造不出来联合查询的语句，然后准备用sqlmap跑一下，出现了NULL这个东东，巧了，这个我在burpsuite的实验室也看到过：</p><p><code>id=-3159&#39; UNION ALL SELECT NULL,CONCAT(0x716a716b71,0x7674475a49545048426e43434d54486f754e466a5053586a486d4d76775156466774437061495079,0x716b7a6b71),NULL#</code></p><p>这里有两个东西不太懂，一个是NULL。另一个是union all select</p><p> 首先说第一个，NULL，根据chatgpt的结果null总共有一下4个作用：</p><ul><li>在数据库表中表示该字段没有值</li><li>在 SQL 语句中表示缺失值或不确定值</li><li>在 UNION SELECT 语句中填充缺失的字段</li><li>在需要在某个字段中显示一个空值的情况下使用</li></ul><p>我猜想这里应该就是第三点吧，其实想了想，貌似没啥用，下面说第二个，作用也不大（无语.jpg）union select和union allselect的主要区别是union select会从最终结果中删除重复行内，而union all select不会，就是酱紫。</p><p>对了，今天玩了会每个大学教授的<a href="https://github.com/phyver/GameShell">gameshell</a>，说实话挺有趣的，也学习到了一些linux的命令，包括</p><ul><li>ls：列出当前目录下的所有文件</li><li>cd：返回主目录</li><li>cd ..:返回上一层</li><li>cd -:返回上一次操作的目录</li><li>pwd：列出当前的主目录</li><li>mkdir：make dirsearch，英文应该是这样写，意思是创建一个文件夹</li><li>rm：remove，移除</li><li>mv：move，移动文件</li><li>cd DIR&#x2F;DIR&#x2F;DIR：移动到指定文件夹，ps，<del>代表根目录，有些时候我们移动文件的时候跨度会很大，需要</del>来进行指向</li><li>ls -A列出当前文件夹的所有目录，包括隐藏的文件，有些文件隐藏后单纯的使用ls是不会显示出来的，这时候我们就需要-A了</li></ul><p>好了，以上就是今天学习的内容了，再接再厉吧，往事已成烟云，未来依旧可期。</p><p>  补充一点，NULL不是没用，根据我在某一篇博客上的说法，mssql联合注入我们一般不使用 数字占位，而是null，因为你使用数字占位可能会发生隐式转换，也就是说数字占位的话可能报错，所以最后使用NULL。</p><p>  再补充，过滤了or 和 and，这种阻拦目前我已知有2中绕过方法，一种就是我上面写的那个，比如把or写成oorr之类的，另一种方法就是可以把and改成&amp;&amp;，把or改成||，也是不错的方法。</p><p>  😤😤😤😤再再补充一点，group_concat()和concat_ws()的区别：如果要将一组数据中的所有行的某一个字段值拼接起来，那么可以使用GROUP_CONCAT()。如果要将多个字符串拼接起来并且要在中间插入一个特殊字符，那么可以使用CONCAT_WS().ps，group_concat()有一个可控字符，也就是字段值，concat_ws()有两个可控字符，第一个是插入的特殊字符，第二个是字段值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是sqllab-25关，总体来说是比较简单的。首先，根据题目‘your or &amp;amp; and is mine’可知作者在创作这关的时候把or和and处理了，好在作者比较贴心地在下面给出了你输入的语句在后台的显示情况。&lt;/p&gt;
&lt;p&gt;首先我们可以测试一下，输入单引号（</summary>
      
    
    
    
    
    <category term="sql注入 渗透测试" scheme="https://huaerjiejue.github.io/tags/sql%E6%B3%A8%E5%85%A5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>sql注入之cookie注入</title>
    <link href="https://huaerjiejue.github.io/2023/01/07/sql%E6%B3%A8%E5%85%A5%E4%B9%8Bcookie%E6%B3%A8%E5%85%A5/"/>
    <id>https://huaerjiejue.github.io/2023/01/07/sql%E6%B3%A8%E5%85%A5%E4%B9%8Bcookie%E6%B3%A8%E5%85%A5/</id>
    <published>2023-01-07T13:04:39.000Z</published>
    <updated>2023-01-12T09:18:25.499Z</updated>
    
    <content type="html"><![CDATA[<p>昨天前天练习cookie注入，有一个问题一直困扰我，今天想了一下，忽然就眼前一亮，貌似大概想明白了，所以赶紧来写一下。</p><p>问题是什么呢，我在做sqllab21，22关的时候，发现了这样一个问题，每次我输入账号admin，密码输入1，当然这里密码是瞎填的，然后页面显示就是成功了，但是回显的信息上显示账号是admin，密码是另外一个东西1‘adn1&#x3D;2#这么一个东西，是我之前做渗透测试的时候写的一个payload了，当时就很迷惑，密码写的1，为什么出来这么一个东东。现在有点明白了，一切都是cookie搞的鬼</p><p>首先写一下自己了解的cookie，当我们与网站服务器相互链接的时候，第一次我们输入账号密码，第二次我们进入该网站就会发现不用继续输入账号密码了，没想到这么多年居然没有注意到这个东西，哎，真遗憾，接着说，之所以会有上面这个现象，是因为当我们第一次向服务此get或post信息的时候，服务器不仅返回我们页面的信息，还有一个cookie，下一次我们进入该网站的时候，我们浏览器就会向服务器发送一个cookie，浏览器<br>收到这个cookie就会知道我们的信息，这样，即使我们不输入相关的账号，密码我们也可以直接登录了，不然每一次登录网站就输入一遍账号密码，岂不是太麻烦了，正因为如此，sql注入的时候除了get，post，还有cookie，当然还有数据包的头部信息，因为这些都是向网站服务器发送信息，这些信息肯定都会与服务器进行交互，也就有了注入的可能。</p><p>好了，大致了解了cookie的原理，然后写一下上面那个问题的原因，原因是什么呢，其实很简单，其实第一次我输入账号密码的时候，服务器会返回一个cookie，这个cookie只包含一个信息，叫做uname，其实就是username的别称，而通过网站源代码可以得知，当服务器通过cookie查询时，他是这样的：</p><p>$sql&#x3D;”SELECT * FROM users WHERE username&#x3D;(‘$cookee’) LIMIT 0,1”;</p><p>就离谱，它指返回username，即只要有账号名称，就可以了，密码神马的它自动帮你查了，怎么说呢，就是，你给他一个名称，他返回给你一串信息，这里包括名称，密码，cookie，http头之类的，这也就是为什么我输入密码为1，他自动给我显示出真实密码的原因，因为他里面有一个isset函数，函数接受一个submit按钮，他的那个信息根本不是我登录返回的信息，他是根据我浏览器传输cookie的信息，因为那段信息的出现的前提条件就是我们有submit，这样一切都真相打败了，我的账号密码是错误的，从来没有通过账号密码登录成功过，这不过因为他的代码的机制，他仍然会返回给我一个cookie，这个cookie是正确的，然后当我刷新界面的时候，没有submit，浏览器上传了cookie，服务器通过上传的cookie，返回给我信息，其中就包括正确的账号名称和密码，并且，服务器也正是根据我的cookie来查询信息，而我也可以通过修改cookie来进行sql语句的注入，over。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天前天练习cookie注入，有一个问题一直困扰我，今天想了一下，忽然就眼前一亮，貌似大概想明白了，所以赶紧来写一下。&lt;/p&gt;
&lt;p&gt;问题是什么呢，我在做sqllab21，22关的时候，发现了这样一个问题，每次我输入账号admin，密码输入1，当然这里密码是瞎填的，然后页面</summary>
      
    
    
    
    
    <category term="sql注入 网络安全 cookie" scheme="https://huaerjiejue.github.io/tags/sql%E6%B3%A8%E5%85%A5-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-cookie/"/>
    
  </entry>
  
  <entry>
    <title>sql注入笔记2</title>
    <link href="https://huaerjiejue.github.io/2023/01/05/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B02/"/>
    <id>https://huaerjiejue.github.io/2023/01/05/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B02/</id>
    <published>2023-01-05T14:50:34.000Z</published>
    <updated>2023-01-05T15:15:00.523Z</updated>
    
    <content type="html"><![CDATA[<p>终于又有时间来练习sqllab了，今天打的是第21关，总算是走出来<br>基础关卡了，开心。</p><p>第21关是联系的cokkie和加密，通过对cookie进行加密来干扰，整体来说不算太难，<br>但是，but，我耗费了很长时间，为什么呢？有以下两点：</p><p>第一点，知道了原理，构造payload的时候出错了，通过闭合后写上了<br>and union select。。。。，这里就是纯纯的大问题，一般构造完之后<br>不用加and，看来还是基础查询语句不够熟悉。</p><p>第二点，这是费时最多的一个点，我带着admin（正确的账号）后面加<br>union select，but union select不是这么用的，在这里简单<br>说一下我的理解，首先，union。肯定前面也要有相同的语句对不对，<br>所以如果前面不是select，但用union select查询大概会出错，<br>其次，由于大部分情况下只有一个回显位，所以有时候前面的查询成功了，<br>我们后面的查询结果就会被覆盖，我们就没有办法看到了，这也是我的问题所在，<br>可以给前面一个错误的信息，后面的查询结果才会显示出来。</p><p>好了，sql此关就算过去了，不知不觉就11点了，对于我这种早睡的<br>人（相较于我认识的大部分人来说）实在是一种煎熬，本想早点睡<br>的，因为明天还要干活去，想了想，还是再写一写自己最近的一些感想吧，<br>毕竟这么多天没写了，属实惭愧，怎么说呢，内心五味杂陈，就是感觉<br>挺累的，不知道这样的生活还要维持多久，但又不确定自己是不是喜欢<br>这样的生活，不知道自己在干什么，不知道怎么干，可能这就是<br>一种迷茫吧，周围一篇雾蒙蒙，自己深陷其中，不想动，不敢动，<br>也没有能力能动，说实话，无数次，我都在想，如果我早早地离开了<br>人世，现在这段生活，这段心境，会不会令我后悔。</p><p>对了，通过这几天自己在github上瞎鼓捣，对docker理解更深层次了<br>一点，有时间也可以写一些，自己还弄了个hyper和alist，不得不说，<br>hyper的颜值属实比windows自带的命令行好看，真不错，不写了，睡觉<br>去了。困死了困死了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;终于又有时间来练习sqllab了，今天打的是第21关，总算是走出来&lt;br&gt;基础关卡了，开心。&lt;/p&gt;
&lt;p&gt;第21关是联系的cokkie和加密，通过对cookie进行加密来干扰，整体来说不算太难，&lt;br&gt;但是，but，我耗费了很长时间，为什么呢？有以下两点：&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>last_day_of_2022</title>
    <link href="https://huaerjiejue.github.io/2022/12/31/last-day-of-2022/"/>
    <id>https://huaerjiejue.github.io/2022/12/31/last-day-of-2022/</id>
    <published>2022-12-31T12:09:29.000Z</published>
    <updated>2022-12-31T12:54:29.294Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2022年最后一天了，回想起博客也好久没写了，正好写一些，<br>其实本没有什么要写的，一方面学习方面大部分没有什么困难的，<br>哎，可能我就是这个伤感的人吧，总想着纪念点。</p><p>颇为意外的是，高考在今年，因为在我的印象中，高考都比较要远离，如果没有从短视频中<br>刷到，我还以为是在去年，怎么说呢，高考结束，没有奇迹发生，一如既往的失败，<br>来到一个新的城市，新的环境，新的人，新的心态，我只希望一切越来越好吧，<br>来到了大学，学校很小，小的装不下我的双脚，我总是想要出去，想要去看看，<br>周围却没有人，或许我们生来就孤单，无时无刻都在孤单，我们总是<br>一个人，不过话说回来，我现在也颇为习惯一个人了，倒不是没有<br>朋友陪自己，只是这些年渐渐也喜欢一个人了，没有约束，没有牢骚<br>。</p><p>哎，心绪太乱，反倒说的烂七八糟了。还是有构架一点的好。</p><p>先说一下好的地方吧，来到了一个不错的城市，学到了自己想要学习的<br>专业，认识了一堆不错的朋友，没有了高考。烦恼也算减轻了一大半，<br>学习的还算过的去，疫情解开了，健健康康，平安。</p><p>不好的地方，进入学校刚买的自行车学校就禁止骑车了，好无语，还有，<br>江泽民老先生去世了，家里的狗狗也去世了，俄乌战争还在继续，国内与国外两种<br>势力还在对抗，自己的思绪还是飘摇不定。定下的一些目标也是没有<br>实现，希望下一年继续努力吧。</p><p>哎，写到这里吧，临表涕零，不知所言。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是2022年最后一天了，回想起博客也好久没写了，正好写一些，&lt;br&gt;其实本没有什么要写的，一方面学习方面大部分没有什么困难的，&lt;br&gt;哎，可能我就是这个伤感的人吧，总想着纪念点。&lt;/p&gt;
&lt;p&gt;颇为意外的是，高考在今年，因为在我的印象中，高考都比较要远离，如果没有从短视</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>python学习笔记1</title>
    <link href="https://huaerjiejue.github.io/2022/12/25/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>https://huaerjiejue.github.io/2022/12/25/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</id>
    <published>2022-12-25T11:55:24.000Z</published>
    <updated>2022-12-25T13:55:27.723Z</updated>
    
    <content type="html"><![CDATA[<p>今天拿起久违的python，准备好好学习一下，好家伙，上来就被面向对象干蒙了，<br>我是谁，我在哪，好在经过一个下午的长时间按划水与摆烂，终于弄明白了，接下来就仔细写一下吧。</p><p>首先介绍下什么是面向对象，对于我来说其实就是一个大包，里面有属性，有方法，属性就是变量，方法就是函数，<br>它们放在一起，叫做类，举个简单的例子，就像是一个专门的柜子，上面存放着属性和方法，可以有很好的便捷性。<br>而且，这个类还有模板的功能，就是可以复制，复制出来的就是对象，对象就是类的实例，就像是柜子里面的东西，<br>每个对象都是这个柜子复刻出来的，但又不太一样。</p><p>而这些对象，有不同的访问权限，有的是公开的，有的是私有的，私有的一般在前面加上‘__’作为私有的标志，<br>这样的话就无法从外面访问到这个变量，只能在内部访问，这样就可以保证数据的安全性。（其实这个私有的对象为什么从外面访问不到，<br>原因是你加上双下划线后这和属性的名字就改变了，所以访问不到了，但是只要掌握命名的话，还是可以访问的，所以不是绝对的安全。）<br>但是太隐蔽了，所以一般程序员经常在命名前面加上一个下划线，表名这是不要碰的，但是你还是可以访问的，这样就可以保证数据的安全性。</p><p>那么就又有问题了，有些时候我们确实需要使这些属性或者方法变成私有的，那么怎么访问和修改呢？<br>聪明的程序员这时就会在这个类里面写一些访问器和修改器，用来从外面访问和修改这些属性和方法。</p><p>这里补充一个知识点，装饰器，一开始学习的资料上直接把装饰器和访问器修改器放到一起，我直接阵亡的好吧。其实完全可以把装饰器这个概念<br>分割开来，它和访问器修改器是两个完全不同的概念，装饰器根据名字就可以判断是用来修饰的，修饰什么呢？其实是修饰函数的，<br>它可以在不改变函数的情况下，给函数功能做一些完善和改正，非常的简单快捷，就是酱紫。</p><p>接下来说回面向对象，那么装饰器是怎么和面向对象扯上关系的呢？我们知道，我们通过访问器和修改器可以来操控私有的类属性，然后通过<br>装饰器来包装这些访问器和修改器，使得对属性的访问既安全又便捷。当然了，有一个修饰器，叫做property，<br>它把一个方法重新包装成一个属性，这样就可以用点运算符来访问和修改这个私有属性了。</p><p>总之，就是我们通过访问器和修改器来控制私有属性，然后通过property这个装饰器再将这个方法包装成属性，成功实现了从一个不可访问修改的属性<br>向另一个属性的移植过程，这样就可以用点运算符来访问和修改这个私有属性了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天拿起久违的python，准备好好学习一下，好家伙，上来就被面向对象干蒙了，&lt;br&gt;我是谁，我在哪，好在经过一个下午的长时间按划水与摆烂，终于弄明白了，接下来就仔细写一下吧。&lt;/p&gt;
&lt;p&gt;首先介绍下什么是面向对象，对于我来说其实就是一个大包，里面有属性，有方法，属性就是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sql注入笔记1</title>
    <link href="https://huaerjiejue.github.io/2022/12/23/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B01/"/>
    <id>https://huaerjiejue.github.io/2022/12/23/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B01/</id>
    <published>2022-12-23T10:07:19.000Z</published>
    <updated>2022-12-24T07:28:44.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sql注入笔记1"><a href="#sql注入笔记1" class="headerlink" title="sql注入笔记1"></a>sql注入笔记1</h1><h2 id="单引号，双引号，括号引用的识别"><a href="#单引号，双引号，括号引用的识别" class="headerlink" title="单引号，双引号，括号引用的识别"></a>单引号，双引号，括号引用的识别</h2><span id="more"></span><p>最近学习渗透测试，从sql入手，做的实战是sqllabs，<br>表示，思路大概都能懂，但是每次都卡壳在对于变量的包装破解上（<br>姑且就让我这么叫把），每次都是脑袋痛，呜呜呜了。</p><p>首先，介绍一下，sql注入的基本原理，就是在输入框中输入一些特殊的字符，来达到sql语句的执行，从而达到攻击的目的。那在攻击的<br>过程中呢，就会遇到各种各样的问题，对于变量的包装就是其中一种<br>，一般来说，有一个变量id，正常情况下，id&#x3D;1，那我们渗透测试的时候，可以<br>输入id&#x3D;1’ or 1&#x3D;1#，这样就可以达到攻击的目的，但是，这样的话，就会遇到各种各样的问题，比如，<br>如果开发者对将光秃秃的id改成‘id’，那么我们就无法达到攻击的目的了。<br>而相应的对抗过程呢，我们写几个 ‘ （或者其他），就可以达到攻击的目的了。</p><p>但接下来问题又来了，我们怎么判断开发者在包装的过程中是添加的单引号，双引号，还是其他等等的呢？<br>其实，这个问题，一个一个测试就好了，就是怕测不出来。这里以最简单的测试举例子。</p><p>这里引用的是sqllabs-1的一个题目<br><img src="/img_1.png" alt="img_1.png"></p><p>首先，第一步，你得测吧，简单输个单引号，看看会不会报错。<br><img src="/img_2.png" alt="img_2.png"><br>很好，报错了，这是为什么呢，我们可以想象一下，原来语句是这样的，’id‘<br>，但是我们输入了一个单引号，变成了’id‘’，这样就会报错了，因为这个语句是不完整的。<br>BUTTTT，我们只能证明有没有单引号，但是双引号呢？括号呢？我们还要继续测量。<br>这里因为我比较懒，就不测了。</p><p>其次，我们可以测试了，根据上一步，猜测是单引号，我们总要验证自己猜测的对不对吧。<br>输入？id&#x3D;1’ or 1&#x3D;1–+，看看会不会报错。<br><img src="/img_3.png" alt="img_3.png"><br>成功，说明可以，补充一下，这里的–是注释，因为我们不需要后面的语句了，所以就注释掉了。<br>or 1&#x3D;1叫做万能语句，就是只要是sql语句不出问题，不用管变量的正确与否<br>，都会返回true，这里就是返回了所有的数据。</p><p>最后，我们就可以愉快地开始<del>攻击</del>了，咳咳，渗透，</p><p>最最后，想写一点自己的感想，这是sql注入的第一篇文章，也是我这个博客的第一篇文章，<br>说实话我不知道自己能坚持多久，因为我总是三分钟热度，哎，尽力吧。<br>by the way，我感觉，写博客的意义还挺多，一方面，可以记录一下，<br>方便日后感伤抒怀，哈哈，另一方面，在刚才码字的过程中，感觉自己更清楚了，<br>回想以前，好像确实是这样，总是在总结以为自己掌握的东西的时候，自己的能力<br>又进一步有了提高，而且，还可以抒发一下感情，真不粗。好了，今天的总结就到这里了，<br>接着练习去了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;sql注入笔记1&quot;&gt;&lt;a href=&quot;#sql注入笔记1&quot; class=&quot;headerlink&quot; title=&quot;sql注入笔记1&quot;&gt;&lt;/a&gt;sql注入笔记1&lt;/h1&gt;&lt;h2 id=&quot;单引号，双引号，括号引用的识别&quot;&gt;&lt;a href=&quot;#单引号，双引号，括号引用的识别&quot; class=&quot;headerlink&quot; title=&quot;单引号，双引号，括号引用的识别&quot;&gt;&lt;/a&gt;单引号，双引号，括号引用的识别&lt;/h2&gt;</summary>
    
    
    
    
    <category term="单引号，双引号，括号" scheme="https://huaerjiejue.github.io/tags/%E5%8D%95%E5%BC%95%E5%8F%B7%EF%BC%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%EF%BC%8C%E6%8B%AC%E5%8F%B7/"/>
    
  </entry>
  
</feed>
